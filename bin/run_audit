#!/bin/sh
#
# run_audit
#
# script to run audit tools and email reports to sysadmin
#
# * created: 2011-05-22 Kevin Chan <kefin@makedostudio.com>
# * updated: 2014-10-29 kchan
#
# Add to crontab to run script at regular intervals:
#
# crontab entry to run backup every night @ midnight
# 0 0 * * * /usr/local/audit/bin/run_audit >> /dev/null 2>&1

########################################################################
myname="${0##*/}"
current_wd=$PWD
cd $(dirname "$0")
mydir="${PWD%/}"
cd "$current_wd"
########################################################################


########################################################################
# helper functions

usage()
{
    cat <<EOF
# Script to run audit tools and email reports to sysadmin
#
# Usage: $myname scripts
#   -h              # display usage
#   -X|--dry-run    # do dry-run
EOF
    exit 1
}

########################################################################
# run audit sub-scripts

errors=0
debug=0
dry_run=0

# load config

BASE_DIR="$(dirname $mydir)"
CONFIG_DIR="/etc/audit"
CONFIG="${CONFIG_DIR}/run_audit.conf"
UTILS="${BASE_DIR}/bin/utils"

[ ! -f "$CONFIG" ] && error "Configuration file not found: $CONFIG"
. "$CONFIG"


# error function

exec_error()
{
    printf >&2 "%s\n" "# script error: $1"
    $((errors + 1))
}

# functions to test if sub-script exists and is executable
# * is_executable does minimal filtering and checks if script
#   is executable
# * is_audit_script checks if script is executable and is
#   not a backup or utils or dummy.

is_executable()
{
    local script="$1"
    [ -x "$script" ] || return 1
    case "${script##*/}" in
        $myname|utils)
            return 1
            ;;
        *)
            return 0
            ;;
    esac
}

is_audit_script()
{
    local script="$1"
    [ -x "$script" ] || return 1
    case "${script##*/}" in
        $myname|utils|dummy|*~|*[._-][Bb][Aa][Kk]|-*|\#*\#|*.sw[nop])
            return 1
            ;;
        *)
            return 0
            ;;
    esac
}

# function to run sub-script

run_script()
{
    local script="$1"
    echo >&2 "# running $script ..."
    if [ $dry_run -eq 0 ]; then
        "$script" || errors=$((errors + 1))
    else
        echo "$script"
    fi
    echo >&2 "# done."
}


# parse parameters

scripts=

while [ $# -gt 0 ]
do
    case "$1" in
        -\?|-h|-help|--help)
            usage
            ;;
        -X|--dry-run)
            dry_run=1
            ;;
        -*)
            error "Unknown optin: $1"
            ;;
        *)
            s="${mydir}/$1"
            [ ! -f "$s" ] && error "Script not found: $s"
            scripts="$scripts $1"
            ;;
    esac
    shift
done


if [ $dry_run -ne 0 ]; then
    printf >&2 "# dry run ..."
fi

if [ "X$scripts" = "X" ]; then
    # if no scripts are supplied as parameters, check if
    # DEFAULT_AUDIT_SCRIPTS is defined and use that list.
    # if not defined, loop through scripts in audit bin directory
    # and add all runnable scripts.
    if [ "X$DEFAULT_AUDIT_SCRIPTS" != "X" ]; then
        scripts="$DEFAULT_AUDIT_SCRIPTS"
    else
        for _script in $(find "$mydir" -type f -print | sort)
        do
            case "$_script" in
                *disabled/*)
                    ;;
                *)
                    if is_audit_script "$script"; then
                        _script_name="${_script##*/}"
                        scripts="$scripts $_script_name"
                    fi
                    ;;
            esac
        done
    fi
fi


# loop through scripts and run each one

for s in $scripts
do
    script="${mydir}/${s}"
    if is_executable "$script"; then
        echo >&2 "# [$myname] running script: $script"
        run_script "$script"
    else
        exec_error "$script"
    fi
done

[ "$errors" -eq 0 ] && status=0 || status=1

exit $status
